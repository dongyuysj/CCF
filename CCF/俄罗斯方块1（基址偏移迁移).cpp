//思路是这样：先求出四列中最关键的一列，
//也就是说那一列的一个方块决定着输入的形状能不能继续往下掉，
//我求法是这样，分别求出四列中原始数组能放的最大行数减去输入数组中有1的行数，
//最小值就是关键部位，然后求出输入数组（4*4）的第一行第一列应放在哪里
//先找关键点临界点 找到关键点临界点 就成功了一半 然后从临点出发进行推演
//输入结构和存储结构也是有区别的 比如两个二位数组 在内存中并不连续
//所以要分割条件单元 一个二维数组一个单元 就像搭积木一样 进行使用
//单元组合测试思维（看懂代码的关键在于每个单元功能要深刻感知）
//模板联动实验思维（在某一个单元上的快速实验）
//遍历提取信息思想 横向变动 竖向提取
//基址偏移思想 基址变动 偏移固定
//数组的本质作用就是从某个合适角度存放对应信息 数组本身的坐标如果需要也可以存值 甚至更能够有对应关系
#include<iostream>
using namespace std;
int main(){
    int a[15][10];
    int b[4][4];
    int i,j,s,t;
    int c[4]={14,14,14,14},d[4]={-20,-20,-20,-20};//c[j]=i在下面用来保存原始数组中第j列在第i行可以填充；d[j]=i表示输入数组第j列第i行有1
    //第j列的第i行可以变为1
    for(i=0;i<15;i++)
    for(j=0;j<10;j++)
    cin>>a[i][j];
    for(i=0;i<4;i++)
    for(j=0;j<4;j++)
    cin>>b[i][j];//对于简单的代码并不需要加大括号
    //代码块才需要大括号
    cin>>s;
    s=s-1;//从第s列输入，下标从0开始
    for(i=s;i<s+4;i++)//谁先静止 谁在外面
    //基址偏移
    for(j=0;j<15;j++){
        if(a[j][i]==1){
            c[i-s]=j-1;
            break;//找到原始数组第i列有1的最小行//对应原始数组的最高处
        }
    }
    for(i=0;i<4;i++){
        for(j=0;j<4;j++){
            if(b[j][i]==1)
            d[i]=j;//找到输入数组中第i列有1的最大行//对应插入数组的最低处
        }//遍历提取
    }//数组的本质作用就是从某个合适角度存放对应信息 数组本身的坐标如果需要也可以存值 甚至更能够有对应关系
    int minl=15;
    for(i=0;i<4;i++)
    if(c[i]-d[i]<minl){
        minl=c[i]-d[i];//四个列相减最小值约束方块放置位置，只需要通过这个位置求得输入数组第一个元素放在原始数组的哪个位置即可
        t=i;
    }//也就是找到了距离最近的一列
  //通过不断替换找到最小值
    int h=c[t],h1=d[t];//存储最近一列的上限与下限位置
    for(i=0;i<4;i++)
    for(j=0;j<4;j++){
        if(b[i][j]==1)
        a[h-h1+i][s+j]=b[i][j];//输入数组第[0,0]个元素放在原始数组第[h-h1,s]中
    }//基址位置与相对位移
    for(i=0;i<15;i++){
        for(j=0;j<10;j++){
            if(j!=9)
            cout<<a[i][j]<<' ';
            else
            cout<<a[i][j]<<endl;
        }
    }
}
